
        Pass
        {
            Tags{"LightMode" = "LightweightForward"}

            // Material options generated by graph 

            Blend One Zero

            Cull Back

            ZTest LEqual

            ZWrite On

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            // -------------------------------------
            // Lightweight Pipeline keywords
            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS
            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
            #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
            #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS
            #pragma multi_compile _ _SHADOWS_SOFT
            #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE
            
            // -------------------------------------
            // Unity defined keywords
            #pragma multi_compile _ DIRLIGHTMAP_COMBINED
            #pragma multi_compile _ LIGHTMAP_ON
            #pragma multi_compile_fog

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing
            #pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
            #pragma shader_feature _TERRAIN_INSTANCED_PERPIXEL_NORMAL
            


            #pragma vertex vert
            #pragma fragment frag

            // Defines generated by graph
            #define _NORMALMAP 1
            #define PASSFORWARD 1


            //MS_DEFINES

            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
            
            CBUFFER_START(UnityPerMaterial)

                    //MS_CBUFFER

            CBUFFER_END
            



            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection;
                float3 TangentSpaceViewDirection;
                float3 WorldSpacePosition;
                float4 VertexColor;
                float4 ScreenPosition;
                half4 uv0;
                half4 uv1;

                //MS_V2F
            };
            

            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Normal;
                float3 Emission;
                float Metallic;
                float Smoothness;
                float3 Specular;
                float Occlusion;
                float Alpha;
            };

           
           
            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 color : COLOR;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                float4 texcoord2 : TEXCOORD2;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


            struct GraphVertexOutput
            {
                float4 clipPos                : SV_POSITION;
                DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 0);
                half4 fogFactorAndVertexLight : TEXCOORD1; // x: fogFactor, yzw: vertex light
                float4 shadowCoord            : TEXCOORD2;

                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                float4 VertexColor : COLOR;
                float4 ScreenPosition : TEXCOORD8;
                half4 uv0 : TEXCOORD9;
                half4 uv1 : TEXCOORD10;

                //MS_V2F

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
            };

             //MS_VERTEXMOD

                    //MS_ADAPTER

                    //MS_SHARED_INC

                    //MS_SHARED_HD
                    
            GraphVertexOutput vert (GraphVertexInput v)
            {
                
                GraphVertexOutput o = (GraphVertexOutput)0;
                UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

                v = ApplyMeshModification(v);

                #if _MICROVERTEXMESH
                   Input inp = (Input)0;
                   EncodeVertex(ToAppData(v), inp);
                   FromInput(o, inp);
                #elif _MICRODIGGERMESH
                   Input inp = (Input)0;
                   DiggerEncodeVertex(ToAppData(v), inp);
                   FromInput(o, inp);
                #endif


                // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 VertexColor = v.color;
                float4 ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;
                
                

                // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.VertexColor = VertexColor;
                o.ScreenPosition = ScreenPosition;
                o.uv0 = uv0;
                o.uv1 = uv1;
                

                VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);
                
                // We either sample GI from lightmap or SH.
                // Lightmap UV and vertex SH coefficients use the same interpolator ("float2 lightmapUV" for lightmap or "half3 vertexSH" for SH)
                // see DECLARE_LIGHTMAP_OR_SH macro.
                // The following funcions initialize the correct variable with correct data
                OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST, o.lightmapUV);
                OUTPUT_SH(WorldSpaceNormal, o.vertexSH);

                half3 vertexLight = VertexLighting(vertexInput.positionWS, WorldSpaceNormal);
                half fogFactor = ComputeFogFactor(vertexInput.positionCS.z);
                o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);
                o.clipPos = vertexInput.positionCS;

            #ifdef _MAIN_LIGHT_SHADOWS
                o.shadowCoord = GetShadowCoord(vertexInput);
            #endif
                return o;
            }

                    //MS_AFTERVERTEX

                    //MS_TERRAIN_BODY
                    
                    //MS_BLENDABLE

                    //MS_MAINFUNC

                    SurfaceDescription PopulateSurfaceData(inout SurfaceDescriptionInputs IN)
                    {
                        MicroSplatLayer l = DoMicroSplat(IN);

                        SurfaceDescription surface = (SurfaceDescription)0;
                        surface.Albedo = l.Albedo;
                        surface.Normal = l.Normal;
                        surface.Smoothness = l.Smoothness;
                        surface.Metallic = l.Metallic;
                        surface.Occlusion = l.Occlusion;
                        surface.Emission = l.Emission;
                        surface.Alpha = l.Alpha;
                        return surface;
                    }

            

            half4 frag (GraphVertexOutput IN ) : SV_Target
            {
                UNITY_SETUP_INSTANCE_ID(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
                float4 VertexColor = IN.VertexColor;
                float4 ScreenPosition = IN.ScreenPosition;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;
                float3 TangentSpaceViewDirection = mul(WorldSpaceViewDirection,(float3x3)tangentSpaceTransform).xyz;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

                // Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.WorldSpaceTangent = WorldSpaceTangent;
                surfaceInput.WorldSpaceBiTangent = WorldSpaceBiTangent;
                surfaceInput.WorldSpaceViewDirection = WorldSpaceViewDirection;
                surfaceInput.TangentSpaceViewDirection = TangentSpaceViewDirection;
                surfaceInput.WorldSpacePosition = WorldSpacePosition;
                surfaceInput.VertexColor = VertexColor;
                surfaceInput.ScreenPosition = ScreenPosition;
                surfaceInput.uv0 = uv0;
                surfaceInput.uv1 = uv1;

                ToSurfaceDescInput(IN, surfaceInput);

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);
                // MICROSPLAT: these can be modified, so copy out
                WorldSpaceNormal = surfaceInput.WorldSpaceNormal;
                WorldSpaceTangent = surfaceInput.WorldSpaceTangent;
                WorldSpaceBiTangent = surfaceInput.WorldSpaceBiTangent;

                float3 Albedo = float3(0.5, 0.5, 0.5);
                float3 Specular = float3(0, 0, 0);
                float Metallic = 1;
                float3 Normal = float3(0, 0, 1);
                float3 Emission = 0;
                float Smoothness = 0.5;
                float Occlusion = 1;
                float Alpha = 1;

                // Surface description remap performed by graph
                Albedo = surf.Albedo;
                Normal = surf.Normal;
                Emission = surf.Emission;
                Metallic = surf.Metallic;
                Smoothness = surf.Smoothness;
                Occlusion = surf.Occlusion;
                Alpha = surf.Alpha;

                #if _RENDERBAKE
                return half4(Albedo, Alpha);
                #endif

                InputData inputData;
                inputData.positionWS = WorldSpacePosition;
                inputData.normalWS = normalize(TransformTangentToWorld(Normal, half3x3(WorldSpaceTangent, WorldSpaceBiTangent, WorldSpaceNormal)));
                inputData.viewDirectionWS = normalize(WorldSpaceViewDirection);
                inputData.shadowCoord = IN.shadowCoord;
                inputData.fogCoord = IN.fogFactorAndVertexLight.x;
                inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;
                inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.vertexSH, inputData.normalWS);

                half4 color = LightweightFragmentPBR(
                    inputData, 
                    Albedo, 
                    Metallic, 
                    Specular, 
                    Smoothness, 
                    Occlusion, 
                    Emission, 
                    Alpha);

                // Computes fog factor per-vertex
                color.rgb = MixFog(color.rgb, IN.fogFactorAndVertexLight.x);
                
                return color;
            }

            ENDHLSL
        }
        Pass
        {
            Name "ShadowCaster"
            Tags{"LightMode" = "ShadowCaster"}

            ZWrite On ZTest LEqual

            // Material options generated by graph
            Cull Back

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing
            #pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap
            #pragma shader_feature _TERRAIN_INSTANCED_PERPIXEL_NORMAL

            #define PASSSHADOW 1

            #pragma vertex ShadowPassVertex
            #pragma fragment ShadowPassFragment

            // Defines generated by graph
            #define _NORMALMAP 1

            //MS_DEFINES

            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

            
            
            CBUFFER_START(UnityPerMaterial)

                    //MS_CBUFFER

            CBUFFER_END
            
            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection;
                float3 TangentSpaceViewDirection;
                float3 WorldSpacePosition;
                float4 VertexColor;
                float4 ScreenPosition;
                half4 uv0;
                half4 uv1;

                //MS_V2F
            };

            
            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Emission;
                float Alpha;
            };
            
            

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 color : COLOR;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                float4 texcoord2 : TEXCOORD2;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


            struct VertexOutput
            {
                float2 uv           : TEXCOORD0;
                float4 clipPos      : SV_POSITION;
                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                float4 VertexColor : COLOR;
                float4 ScreenPosition : TEXCOORD8;
                half4 uv0 : TEXCOORD9;
                half4 uv1 : TEXCOORD10;

                //MS_V2F

                UNITY_VERTEX_INPUT_INSTANCE_ID
            };

            //MS_VERTEXMOD

                    //MS_ADAPTER

                    //MS_SHARED_INC

                    //MS_SHARED_HD

                    
            // x: global clip space bias, y: normal world space bias
            float4 _ShadowBias;
            float3 _LightDirection;

            VertexOutput ShadowPassVertex(GraphVertexInput v)
            {
                
                VertexOutput o;
                UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);

                v = ApplyMeshModification(v);
                // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 VertexColor = v.color;
                float4 ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;
                

                // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.VertexColor = VertexColor;
                o.ScreenPosition = ScreenPosition;
                o.uv0 = uv0;
                o.uv1 = uv1;

                
                float3 positionWS = TransformObjectToWorld(v.vertex.xyz);
                float3 normalWS = TransformObjectToWorldDir(v.normal);

                float invNdotL = 1.0 - saturate(dot(_LightDirection, normalWS));
                float scale = invNdotL * _ShadowBias.y;

                // normal bias is negative since we want to apply an inset normal offset
                positionWS = normalWS * scale.xxx + positionWS;
                float4 clipPos = TransformWorldToHClip(positionWS);

                // _ShadowBias.x sign depens on if platform has reversed z buffer
                clipPos.z += _ShadowBias.x;

            #if UNITY_REVERSED_Z
                clipPos.z = min(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
            #else
                clipPos.z = max(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
            #endif
                o.clipPos = clipPos;

                return o;
            }

            //MS_AFTERVERTEX

                    //MS_TERRAIN_BODY
                    
                    //MS_BLENDABLE

                    //MS_MAINFUNC

                    SurfaceDescription PopulateSurfaceData(inout SurfaceDescriptionInputs IN)
                    {
                        MicroSplatLayer l = DoMicroSplat(IN);

                        SurfaceDescription surface = (SurfaceDescription)0;
                        surface.Albedo = l.Albedo;
                        surface.Emission = l.Emission;
                        surface.Alpha = l.Alpha;
                        return surface;
                    }

                    

            half4 ShadowPassFragment(VertexOutput IN ) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
                float4 VertexColor = IN.VertexColor;
                float4 ScreenPosition = IN.ScreenPosition;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;
                float3 TangentSpaceViewDirection = mul(WorldSpaceViewDirection,(float3x3)tangentSpaceTransform).xyz;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

                // Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.WorldSpaceTangent = WorldSpaceTangent;
                surfaceInput.WorldSpaceBiTangent = WorldSpaceBiTangent;
                surfaceInput.WorldSpaceViewDirection = WorldSpaceViewDirection;
                surfaceInput.TangentSpaceViewDirection = TangentSpaceViewDirection;
                surfaceInput.WorldSpacePosition = WorldSpacePosition;
                surfaceInput.VertexColor = VertexColor;
                surfaceInput.ScreenPosition = ScreenPosition;
                surfaceInput.uv0 = uv0;
                surfaceInput.uv1 = uv1;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

                float3 Albedo = float3(0.5, 0.5, 0.5);
                float3 Emission = 0;
                float Alpha = 1;

                // Surface description remap performed by graph
                Albedo = surf.Albedo;
                Emission = surf.Emission;
                Alpha = surf.Alpha;
 
                return 0;
            }

            ENDHLSL
        }

        Pass
        {
            Name "DepthOnly"
            Tags{"LightMode" = "DepthOnly"}

            ZWrite On
            ColorMask 0

            // Material options generated by graph
            Cull Back

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing
            #pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap 
            #pragma shader_feature _TERRAIN_INSTANCED_PERPIXEL_NORMAL

            #pragma vertex vert
            #pragma fragment frag

            // Defines generated by graph
            #define _NORMALMAP 1
            #define PASSDEPTH 1

            //MS_DEFINES

            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
            
            CBUFFER_START(UnityPerMaterial)

                    //MS_CBUFFER

            CBUFFER_END
            
            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection;
                float3 TangentSpaceViewDirection;
                float3 WorldSpacePosition;
                float4 VertexColor;
                float4 ScreenPosition;
                half4 uv0;
                half4 uv1;
            };

            
            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Emission;
                float Alpha;
            };

            
            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 color : COLOR;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                float4 texcoord2 : TEXCOORD2;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


            struct VertexOutput
            {
                float2 uv           : TEXCOORD0;
                float4 clipPos      : SV_POSITION;
                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                float4 VertexColor : COLOR;
                float4 ScreenPosition : TEXCOORD8;
                half4 uv0 : TEXCOORD9;
                half4 uv1 : TEXCOORD10;

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
            };

            //MS_VERTEXMOD

                    //MS_ADAPTER

                    //MS_SHARED_INC

                    //MS_SHARED_HD
                    
            VertexOutput vert(GraphVertexInput v)
            {
                VertexOutput o = (VertexOutput)0;
                UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

                v = ApplyMeshModification(v);

                // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 VertexColor = v.color;
                float4 ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;
                

                // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.VertexColor = VertexColor;
                o.ScreenPosition = ScreenPosition;
                o.uv0 = uv0;
                o.uv1 = uv1;

                o.clipPos = TransformObjectToHClip(v.vertex.xyz);
                return o;
            }

            //MS_AFTERVERTEX
            
                    //MS_TERRAIN_BODY
                    
                    //MS_BLENDABLE

                    //MS_MAINFUNC

                    SurfaceDescription PopulateSurfaceData(inout SurfaceDescriptionInputs IN)
                    {
                        MicroSplatLayer l = DoMicroSplat(IN);

                        SurfaceDescription surface = (SurfaceDescription)0;
                        surface.Albedo = l.Albedo;
                        surface.Emission = l.Emission;
                        surface.Alpha = l.Alpha;
                        return surface;
                    }

                    

            half4 frag(VertexOutput IN ) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
                float4 VertexColor = IN.VertexColor;
                float4 ScreenPosition = IN.ScreenPosition;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;
                float3 TangentSpaceViewDirection = mul(WorldSpaceViewDirection,(float3x3)tangentSpaceTransform).xyz;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

                // Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.WorldSpaceTangent = WorldSpaceTangent;
                surfaceInput.WorldSpaceBiTangent = WorldSpaceBiTangent;
                surfaceInput.WorldSpaceViewDirection = WorldSpaceViewDirection;
                surfaceInput.TangentSpaceViewDirection = TangentSpaceViewDirection;
                surfaceInput.WorldSpacePosition = WorldSpacePosition;
                surfaceInput.VertexColor = VertexColor;
                surfaceInput.ScreenPosition = ScreenPosition;
                surfaceInput.uv0 = uv0;
                surfaceInput.uv1 = uv1;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

                float3 Albedo = float3(0.5, 0.5, 0.5);
                float3 Emission = 0;
                float Alpha = 1;

                // Surface description remap performed by graph
                Albedo = surf.Albedo;
                Emission = surf.Emission;
                Alpha = surf.Alpha;

                return 0;
            }
            ENDHLSL
        }

        // This pass it not used during regular rendering, only for lightmap baking.
        Pass
        {
            Name "Meta"
            Tags{"LightMode" = "Meta"}

            Cull Off

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            #pragma vertex vert
            #pragma fragment frag

            float4 _MainTex_ST;

            // Defines generated by graph
            #define _NORMALMAP 1
            #define PASSMETA 1

            //MS_DEFINES

            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/MetaInput.hlsl"
            #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
            
            
            CBUFFER_START(UnityPerMaterial)

                    //MS_CBUFFER

            CBUFFER_END
            
            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection;
                float3 TangentSpaceViewDirection;
                float3 WorldSpacePosition;
                float4 VertexColor;
                float4 ScreenPosition;
                half4 uv0;
                half4 uv1;

                //MS_V2F
            };

            
         
            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Emission;
                float Alpha;
            };
            
            


            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 color : COLOR;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                float4 texcoord2 : TEXCOORD2;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


            struct VertexOutput
            {
                float2 uv           : TEXCOORD0;
                float4 clipPos      : SV_POSITION;
                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                float4 VertexColor : COLOR;
                float4 ScreenPosition : TEXCOORD8;
                half4 uv0 : TEXCOORD9;
                half4 uv1 : TEXCOORD10;

                //MS_V2F

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
            };


            //MS_VERTEXMOD

                    //MS_ADAPTER

                    //MS_SHARED_INC

                    //MS_SHARED_HD

                    
            VertexOutput vert(GraphVertexInput v)
            {
                
                VertexOutput o = (VertexOutput)0;
                UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

                v = ApplyMeshModification(v);

                #if _MICROVERTEXMESH
                   Input inp = (Input)0;
                   EncodeVertex(ToAppData(v), inp);
                   FromInput(o, inp);
                #elif _MICRODIGGERMESH
                   Input inp = (Input)0;
                   DiggerEncodeVertex(ToAppData(v), inp);
                   FromInput(o, inp);
                #endif

                // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 VertexColor = v.color;
                float4 ScreenPosition = ComputeScreenPos(mul(GetWorldToHClipMatrix(), mul(GetObjectToWorldMatrix(), v.vertex)), _ProjectionParams.x);
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;


                // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.VertexColor = VertexColor;
                o.ScreenPosition = ScreenPosition;
                o.uv0 = uv0;
                o.uv1 = uv1;

                o.clipPos = MetaVertexPosition(v.vertex, uv1, uv1, unity_LightmapST);
                return o;
            }

            //MS_AFTERVERTEX
                    

                    //MS_TERRAIN_BODY
                    
                    //MS_BLENDABLE

                    //MS_MAINFUNC

                    SurfaceDescription PopulateSurfaceData(inout SurfaceDescriptionInputs IN)
                    {
                        MicroSplatLayer l = DoMicroSplat(IN);

                        SurfaceDescription surface = (SurfaceDescription)0;
                        surface.Albedo = l.Albedo;
                        surface.Emission = l.Emission;
                        surface.Alpha = l.Alpha;
                        return surface;
                    }
                    

            half4 frag(VertexOutput IN ) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
                float4 VertexColor = IN.VertexColor;
                float4 ScreenPosition = IN.ScreenPosition;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;
                float3 TangentSpaceViewDirection = mul(WorldSpaceViewDirection,(float3x3)tangentSpaceTransform).xyz;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

                // Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.WorldSpaceTangent = WorldSpaceTangent;
                surfaceInput.WorldSpaceBiTangent = WorldSpaceBiTangent;
                surfaceInput.WorldSpaceViewDirection = WorldSpaceViewDirection;
                surfaceInput.TangentSpaceViewDirection = TangentSpaceViewDirection;
                surfaceInput.WorldSpacePosition = WorldSpacePosition;
                surfaceInput.VertexColor = VertexColor;
                surfaceInput.ScreenPosition = ScreenPosition;
                surfaceInput.uv0 = uv0;
                surfaceInput.uv1 = uv1;

                ToSurfaceDescInput(IN, surfaceInput);

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

                float3 Albedo = float3(0.5, 0.5, 0.5);
                float3 Emission = 0;
                float Alpha = 1;

                // Surface description remap performed by graph
                Albedo = surf.Albedo;
                Emission = surf.Emission;
                Alpha = surf.Alpha;

                MetaInput metaInput = (MetaInput)0;
                metaInput.Albedo = Albedo;
                metaInput.Emission = Emission;
                
                return MetaFragment(metaInput);
            }
            ENDHLSL
        }
        UsePass "Hidden/Nature/Terrain/Utilities/PICKING"
        UsePass "Hidden/Nature/Terrain/Utilities/SELECTION"
